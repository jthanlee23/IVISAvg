<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>IVIS Group Optimizer</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f9fafb;
      margin: 0;
      padding: 2rem;
      color: #111827;
      display: flex;
      justify-content: center;
    }

    .container {
      max-width: 800px;
      width: 100%;
      background: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.05);
    }

    h1 {
      text-align: center;
      font-size: 1.8rem;
      margin-bottom: 1.5rem;
      color: #1f2937;
    }

    label {
      display: block;
      margin: 0.8rem 0 0.3rem;
      font-weight: 600;
    }

    input, textarea, select {
      width: 100%;
      padding: 0.7rem;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 1rem;
      background-color: #f9fafb;
      transition: border-color 0.3s;
    }

    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #3b82f6;
      background-color: white;
    }

    textarea {
      resize: vertical;
      min-height: 100px;
    }

    button {
      margin-top: 1.2rem;
      padding: 0.7rem 1.2rem;
      border: none;
      border-radius: 8px;
      background-color: #3b82f6;
      color: white;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.3s;
      width: 100%;
    }

    button:hover {
      background-color: #2563eb;
    }

    .warning {
      color: #dc2626;
      font-weight: 600;
      margin-top: 1rem;
      white-space: pre-wrap;
      background-color: #fef2f2;
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid #fca5a5;
    }

    .output {
      background: #f3f4f6;
      padding: 1rem;
      margin-top: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
      white-space: pre-wrap;
      font-family: monospace;
    }

    .section {
      margin-top: 2rem;
    }

    .group-prefs select {
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>IVIS Group Optimizer</h1>

    <label for="dataInput">Paste Data (Tab or Comma Delimited):</label>
    <textarea id="dataInput" placeholder="Example:&#10;123\t3.0E+5&#10;456\t2.8E+5 or 123,3.0E+5"></textarea>

    <div class="section">
      <label for="lowerLimit">Lower Fluorescence Limit:</label>
      <input type="number" id="lowerLimit" value="200000" step="any">

      <label for="upperLimit">Upper Fluorescence Limit:</label>
      <input type="number" id="upperLimit" value="7500000" step="any">
    </div>

    <div class="section">
      <label for="tolerance">Average Spread Tolerance (Â±):</label>
      <input type="number" id="tolerance" value="300000" step="any">
    </div>

    <div class="section">
      <label for="numGroups">Number of Groups:</label>
      <input type="number" id="numGroups" min="1" required oninput="generateGroupPreferences()">

      <label for="micePerGroup">Mice per Group:</label>
      <input type="number" id="micePerGroup" min="1" required>

      <div id="groupPreferences" class="group-prefs"></div>
    </div>

    <button onclick="optimizeGroups()">Optimize Groups</button>
    <button onclick="rerunOptimization()" style="background-color: #6b7280;">Rerun Optimization</button>

    <div id="warning" class="warning" style="display:none;"></div>

    <div class="section">
      <h2>Optimized Group Assignments</h2>
      <div id="output" class="output"></div>
    </div>
  </div>

  <script>
    let lastMice = [], lastOmitted = [], lastPrefs = [], lastNumGroups = 0, lastMicePerGroup = 0, lastTolerance = 0;

    function updateWarning(msg) {
      const warningBox = document.getElementById('warning');
      warningBox.textContent = msg;
      warningBox.style.display = msg.trim() ? 'block' : 'none';
    }

    function parseData(input) {
      const lower = parseFloat(document.getElementById('lowerLimit').value);
      const upper = parseFloat(document.getElementById('upperLimit').value);
      const lines = input.trim().split('\n');
      const parsed = [], omitted = [], errors = [];
      lines.forEach((row, index) => {
        const parts = row.includes(',') ? row.split(',') : row.split('\t');
        if (parts.length < 2) {
          errors.push(`Invalid row ${index + 1}: '${row}'`);
          return;
        }
        const id = parts[0].trim();
        const value = parseFloat(parts[1].trim());
        if (!id || isNaN(value)) {
          errors.push(`Malformed data at row ${index + 1}: '${row}'`);
        } else if (value < lower || value > upper) {
          omitted.push({ id, fluorescence: value });
        } else {
          parsed.push({ id, fluorescence: value });
        }
      });
      return { parsed, omitted, errors, lower, upper };
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function generateGroupPreferences() {
      const numGroups = parseInt(document.getElementById('numGroups').value) || 0;
      const container = document.getElementById('groupPreferences');
      container.innerHTML = '';
      if (numGroups < 1) return;
      for (let i = 0; i < numGroups; i++) {
        const lbl = document.createElement('label');
        lbl.textContent = `Group ${i + 1} Preference:`;
        const sel = document.createElement('select');
        sel.id = `groupPref${i}`;
        ['similar', 'greater', 'smaller'].forEach(opt => {
          const o = document.createElement('option');
          o.value = opt;
          o.textContent = opt.charAt(0).toUpperCase() + opt.slice(1);
          sel.appendChild(o);
        });
        container.appendChild(lbl);
        container.appendChild(sel);
      }
    }

    function assignGroupsOptimized(mice, numGroups, micePerGroup, prefs, tolerance) {
      let bestGroups = null, bestSpread = Infinity;
      const totalMice = mice.length;
      const globalAvg = mice.reduce((sum, m) => sum + m.fluorescence, 0) / totalMice;
      const sd = Math.sqrt(mice.reduce((acc, m) => acc + Math.pow(m.fluorescence - globalAvg, 2), 0) / totalMice);

      for (let t = 0; t < 1000; t++) {
        const targets = Array(numGroups).fill(globalAvg).map((_, i) => {
          if (prefs[i] === 'greater') return globalAvg + (sd + Math.random() * sd);
          if (prefs[i] === 'smaller') return globalAvg - (sd + Math.random() * sd);
          return globalAvg;
        });

        const shuffled = shuffle([...mice]);
        const groups = Array.from({ length: numGroups }, () => []);
        const sums = Array(numGroups).fill(0);

        for (const m of shuffled) {
          const candidates = [];
          for (let i = 0; i < numGroups; i++) {
            if (groups[i].length < micePerGroup) candidates.push(i);
          }
          let chosen = candidates[0];
          let bestDelta = Infinity;
          candidates.forEach(i => {
            const newAvg = (sums[i] + m.fluorescence) / (groups[i].length + 1);
            const delta = Math.abs(newAvg - targets[i]);
            if (delta < bestDelta) { bestDelta = delta; chosen = i; }
          });
          groups[chosen].push(m);
          sums[chosen] += m.fluorescence;
        }

        const avgs = sums.map(s => s / micePerGroup);
        const spread = Math.max(...avgs) - Math.min(...avgs);
        if (spread <= tolerance) return groups;
        if (spread < bestSpread) { bestSpread = spread; bestGroups = groups; }
      }
      return bestGroups;
    }

    function optimizeGroups() {
      const raw = document.getElementById('dataInput').value;
      const numGroups = parseInt(document.getElementById('numGroups').value);
      const micePerGroup = parseInt(document.getElementById('micePerGroup').value);
      const tolerance = parseFloat(document.getElementById('tolerance').value);
      const { parsed: mice, omitted, errors, lower, upper } = parseData(raw);
      const prefs = Array.from({ length: numGroups }, (_, i) => document.getElementById(`groupPref${i}`)?.value || 'similar');

      let msg = errors.join('\n');
      msg += `\n${mice.length} usable entries (between ${lower} and ${upper}).`;
      if (omitted.length > 0) {
        msg += `\n${omitted.length} exclusions:`;
        omitted.forEach(o => { msg += `\n  ${o.id}: ${o.fluorescence.toExponential(2)}`; });
      }
      updateWarning(msg);

      if (mice.length !== numGroups * micePerGroup) {
        alert(`Mismatch: ${mice.length} usable entries cannot form ${numGroups} groups of ${micePerGroup}.`);
        return;
      }

      lastMice = mice; lastOmitted = omitted; lastPrefs = prefs;
      lastNumGroups = numGroups; lastMicePerGroup = micePerGroup; lastTolerance = tolerance;

      runAssignment(mice, numGroups, micePerGroup, prefs, omitted, tolerance);
    }

    function rerunOptimization() {
      if (!lastMice.length) return alert('Please run optimizer first.');
      runAssignment(lastMice, lastNumGroups, lastMicePerGroup, lastPrefs, lastOmitted, lastTolerance);
    }

    function runAssignment(mice, numGroups, micePerGroup, prefs, omitted, tolerance) {
      const groups = assignGroupsOptimized(mice, numGroups, micePerGroup, prefs, tolerance);
      let out = '';
      groups.forEach((g, i) => {
        const sum = g.reduce((a, b) => a + b.fluorescence, 0);
        const avg = sum / g.length;
        out += `Group ${i+1} (Avg: ${avg.toExponential(2)}):\n`;
        g.forEach(m => { out += `  ${m.id}: ${m.fluorescence.toExponential(2)}\n`; });
        out += '\n';
      });
      if (omitted.length > 0) {
        out += '--- Omitted Data Points ---\n';
        omitted.forEach(o => { out += `  ${o.id}: ${o.fluorescence.toExponential(2)}\n`; });
      }
      document.getElementById('output').textContent = out;
    }
  </script>
</body>
</html>
